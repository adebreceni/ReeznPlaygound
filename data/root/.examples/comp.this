{"content":"class op{\n    def |[N <: op](next: N) = seq(this, next)\n}\n\nclass seq[A <: op, B <: op] = op{\n    val op1: A\n    val op2: B\n    def apply[S <: ](state: S) = op2(op1(state))\n}\n\nclass mov[Src, Dst]{\n    val src: Src\n    val dst: Dst\n    def apply[S <: {[Src]: _}](state: S): state with {[Dst]: state[Src]}\n}\n\nclass xor[Src, Dst]{\n    val src: Src\n    val dst: Dst\n    def apply[S <: {[Src]: u32, [Dst]: u32}](state: S): state with {[Dst]: u32} where `this[Dst] == state[Src] ^ state[Dst]`\n}\n\nenum Reg{\n    eax, ebx\n}\n\nval fn = // : seq[mov[Reg.eax, Reg.ebx], xor[Reg.eax, Reg.eax]]\n    mov(Reg.eax, Reg.ebx) | // calls op.|[xor[Reg.eax, Reg.eax]]\n    xor(Reg.eax, Reg.eax)\n\ndef inv[S <: {[Reg.eax]: _}](state: S, key: string, p: `key != Reg.ebx`) = {\n    val newState = mov(Reg.eax, Reg.ebx)(state) // : state with {[Reg.ebx]: state[Reg.eax]}\n    val v = newState[key] // : (`key == Reg.ebx` & state[Reg.eax]) | (`key != Reg.ebx` & state[key])\n}","test_result":{"errors":[{"range":{"start":{"row":7,"column":14},"end":{"row":7,"column":18}},"message":"Unknown error"},{"range":{"start":{"row":13,"column":14},"end":{"row":13,"column":24}},"message":"Unknown error"}],"annotations":[]}}
{"content":"// This is a quick glance on the language, for \n// more, check out the examples on the left or \n// take a look at the docs\n\n// define packages \npackage P{\n\tval myValue = 5\n}\n// define type aliases\ntype UInt32 = u32\n// define structural types\ntype WithX{\n\tval x: i32\n}\n\n// define classes\n// they behave as nominal types\nclass A{\n\t// with a single member \"x\" of type \"i32\"\n\tval x: i32\n}\n\n// we have intersection types \n// and union types\ntype R = \"a\" | \"b\"\ntype U = WithX & {val y: i32}\n\n// and most importantly\n// we have expression types;\n// think of Scala's path dependent\n// types, but on roids;\n// they are singletons containing\n// only the value of such an expression\n\n// with literal and intersection types\n// they are useful to create detailed\n// constraints on the values\n\n// this function can only be called \n// if you provide a \"proof\" such that \n// the first arg is less than \"5\"\ndef f(x: i32, p: `x < 5` & true): u32 = ...\n","test_result":{"errors":[],"annotations":[]}}